#!/usr/bin/perl

use strict;      # Включаем строгий режим для обязательного объявления переменных и лучшей проверки ошибок.
use warnings;    # Включаем предупреждения для выявления потенциальных проблем в коде.
use Cwd 'abs_path';  # Импортируем функцию abs_path из модуля Cwd для получения абсолютного пути к каталогу.

# Получаем аргументы из командной строки.
# $dir - путь к корневому каталогу для обхода.
# $ext - расширение файлов для удаления (например, '.txt').
my ($dir, $ext) = @ARGV;

# Если каталог не указан в аргументах, запрашиваем его у пользователя.
if (not defined $dir) {
    print "Введите каталог для просмотра: ";
    chomp($dir = <>);  # Считываем ввод и удаляем символ новой строки.
}

# Если расширение не указано в аргументах, запрашиваем его у пользователя.
if (not defined $ext) {
    print "Введите расширение файлов для удаления (например, .txt): ";
    chomp($ext = <>);  # Считываем ввод и удаляем символ новой строки.
}

# Преобразуем путь к каталогу в абсолютный для избежания проблем с относительными путями.
$dir = abs_path($dir);

# Проверяем, существует ли указанный каталог и является ли он директорией.
# Если нет, выводим ошибку и завершаем программу.
if (! -d $dir) {
    die "Указанный каталог '$dir' не существует или не является директорией.\n";
}

# Исправляем расширение: если оно начинается с точки, удаляем точку для правильного сравнения.
# Например, '.txt' становится 'txt'.
if ($ext =~ /^\./) {
    $ext = substr($ext, 1);
}

# Запрашиваем подтверждение у пользователя перед началом удаления файлов.
# Это предотвращает случайное удаление важных данных.
print "Вы действительно хотите удалить все файлы с расширением '.$ext' в каталоге '$dir' и его подкаталогах? (y/n): ";
chomp(my $confirm = <>);
if (lc($confirm) ne 'y') {
    print "Операция отменена.\n";
    exit;
}

# Рекурсивная функция для удаления файлов с заданным расширением.
# Параметры:
# - $current_dir: текущий каталог (абсолютный путь) для обработки.
sub delete_files_with_extension {
    my ($current_dir) = @_;
    
    # Переходим в текущий каталог.
    # Если не удается, завершаем с ошибкой.
    chdir($current_dir) or die "Не могу перейти в каталог '$current_dir': $!";
    
    # Открываем текущий каталог для чтения.
    # Если не удается, завершаем с ошибкой.
    opendir(my $DIR, ".") or die "Не могу открыть каталог '$current_dir': $!";
    
    # Читаем все элементы каталога в массив @files.
    my @files = readdir($DIR);
    
    # Закрываем дескриптор каталога.
    closedir($DIR);

    # Перебираем все элементы в каталоге.
    foreach my $file (@files) {
        # Пропускаем специальные элементы '.', '..', и '.git' для избежания ненужной обработки или удаления.
        next if ($file eq '.' or $file eq '..' or $file eq '.git');

        # Если элемент является директорией.
        if (-d $file) {
            # Рекурсивно вызываем функцию для подкаталога.
            # Передаем абсолютный путь к подкаталогу.
            delete_files_with_extension("$current_dir/$file");
            
        # Если элемент является обычным файлом.
        } elsif (-f $file) {
            # Извлекаем расширение файла: берем последнюю часть после точки.
            # Например, для 'example.txt' расширение 'txt'.
            my $extension = (split /\./, $file)[-1];
            
            # Сравниваем расширение (без точки) с заданным.
            if (defined $extension && $extension eq $ext) {
                # Выводим сообщение о удаляемом файле.
                print "Удаляю файл: $current_dir/$file\n";
                
                # Удаляем файл. Если не удается, выводим предупреждение, но продолжаем.
                unlink($file) or warn "Не могу удалить файл '$file': $!";
            }
        }
    }
    
    # После обработки всех элементов возвращаемся в родительский каталог.
    chdir("..") or die "Не могу вернуться в родительский каталог: $!";
}

# Вызываем рекурсивную функцию для корневого каталога.
delete_files_with_extension($dir);

# Выводим сообщение о завершении операции.
print "Операция завершена.\n";